<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title></title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
html, body { height: 100%; margin: 0; }
body {
  display: grid; place-items: center;
 /* Bild von ChatGPT (BrainTrials) */
  background: black;
  background-size: cover;
  color: white;
  font-family: Arial, sans-pixel; text-align: center;
}
#gameContainer {
  width: 90%; max-width: 700px; min-height: 520px;
  padding: 20px;  border-radius: 15px;
  box-shadow: black; 
  display: flex; flex-direction: column; align-items: center; justify-content: center;
}
#startButton {
  position: fixed;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.6s ease;

}

#tipButton {
  position: fixed;
  bottom: 20px;
  right: -60px;
  background: none;
  border: none;
  font-size: 28px;
  cursor: pointer;
  z-index: 2000;
  opacity: 0;
  transition: right 3s ease, opacity 3s ease;
}

#tipButton.show {
  right: 20px;
  opacity: 1;
}

#tipButton .cube-face {
  display: inline-block;
}

/*  ECHTES ROLLEN */
#tipButton.roll .cube-face {
  animation: cubeRoll 2s ease-out forwards;
}

@keyframes cubeRoll {
  0%   { transform: rotate(0deg); }
  25%  { transform: rotate(-90deg); }
  50%  { transform: rotate(-180deg); }
  75%  { transform: rotate(-270deg); }
  100% { transform: rotate(-360deg); }
}
#tipButton:hover { color: inherit; }

.modal {
  display: none;
  position: fixed;
  z-index: 1001;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: #00000000;
}
.modal-content {
  background-color: #00000000;
  margin: 15% auto;
  padding: 20px;
  border-radius: 12px;
  width: 80%;
  max-width: 400px;
  color: white;
  text-align: left;
  max-height: 75vh; /* maximale H√∂he */
  overflow-y: auto;  /* scrollen, wenn Text zu lang ist */
}
.close {
  color: #00000000;
  float: right;
  font-size: 28px;
  font-weight: bold;
  cursor: pointer;
}
.close:hover { color: #00000000; }
 
h1 { font-size: 1.8em; margin-bottom: 20px; color: #808080; font-family: 'Press Start 2P', cursive; }
#task, #wordDisplay { font-size: 1.4em; margin: 20px 0; min-height: 50px; font-family: 'Press Start 2P', cursive; word-break: keep-all; }
#inputContainer { display: flex; flex-direction: column; align-items: center; }
#playerWord, #answer { width: 80%; max-width: 400px; font-size: 1em; padding: 10px; border-radius: 10px; border: none; margin-bottom: 15px; text-align: center; box-sizingss: border-box; font-family: 'Press Start 2P', cursive; }
button { padding: 12px 25px; font-size: 1em; border: none; border-radius: 10px; background: #808080; color: black; cursor: pointer; transition: all 0.2s; font-family: 'Press Start 2P', cursive; }
button:hover { background: #00000000; }
#message { margin-top: 20px; font-size: 1em; min-height: 40px; font-family: 'Press Start 2P', cursive; }
#timer { margin-top: 15px; font-size: 1em; font-weight: bold; font-family: 'Press Start 2P', cursive; }
.timer-green { color: #4caf50; }
.timer-yellow { color: #ffc107; }
.timer-red { color: #f44336; }

/* ===================== Tic-Tac-Toe & Chromatic Styles ===================== */
#boardWrapper { display: flex; align-items: center; justify-content: center; width: 100%; }
#board { display: grid; grid-template-columns: repeat(3, 120px); grid-template-rows: repeat(3, 120px); gap: 10px; margin-top:20px; }
.cell { width:120px; height:120px; display:flex; align-items:center; justify-content:center; font-family: 'Press Start 2P', cursive; font-size: 35px; cursor:pointer; transition: transform 0.15s, filter 0.15s; color:white; font-weight:bold; border-radius:15px; }
.cell:hover { transform: scale(1.05); filter: brightness(1.15); }
#scoreboard {
  font-size: 0.7em; /* exakt wie "Find the right color" */
}
  #scoreboard {
  margin-top: 10px;
  color: white;
  font-family: 'Press Start 2P', cursive; }
#level span {
  display: none;
}
  #level { margin-top:10px; color:white; font-size: 0.7em;
  font-family: 'Press Start 2P', cursive; }

/* ‚úÖ Dropdown (select) innerhalb von #level ebenfalls anpassen */
#level select {
  font-family: 'Press Start 2P', cursive;
  font-size: 0.7em; /* gleiche Gr√∂√üe wie dein #level Text */
  color: white;     /* damit der Text sichtbar ist */
  background: #000; /* optional, passend zum Spielhintergrund */
  border: 1px solid #808080; /* optional, Rahmen wie Rest des Spiels */
  border-radius: 5px; /* runde Ecken wie √ºberall */
  padding: 2px 5px;   /* kleine Polsterung */

}
  
  #grid { display: grid; grid-template-columns: repeat(3, 120px); grid-template-rows: repeat(3, 120px); gap: 12px; margin-top:20px; }
.tile { width: 120px; height: 120px; border-radius: 15px; cursor: pointer; transition: transform 0.15s, filter 0.15s; }
.tile:hover { transform: scale(1.05); filter: brightness(1.15); }

@media (max-width:600px){
  h1{font-size:1.4em;} #task, #wordDisplay{font-size:1.2em;} #playerWord, #answer{font-size:0.9em;}
  button{font-size:0.9em; padding:10px 20px;} #board{grid-template-columns:repeat(3, 90px);grid-template-rows:repeat(3, 90px);} .cell{width:90px;height:90px;font-size:40px;}
}
@media (max-width:600px){#grid{grid-template-columns: repeat(3, 90px); grid-template-rows: repeat(3, 90px);} .tile{width: 90px; height: 90px;}}
/* ‚ùóÔ∏è Popup-Text = gleicher Style wie "Only the right words will take you further" */
.modal-content p,
.modal-content li {
  font-family: 'Press Start 2P', cursive;
  font-size: 0.8em;
  color: white;
}
.modal.open {
  display: block;
}
#startScreen {
  position: fixed;
  inset: 0;
  background: black;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 3000;
}
#startScreen img {
  max-width: 90%;
  height: auto;
  cursor: pointer;
}

  @keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.2); opacity: 0.8; }
  100% { transform: scale(1); opacity: 1; }
}
  @keyframes softPulse {
  0%   { transform: scale(1); opacity: 1; }
  50%  { transform: scale(1.15); opacity: 0.85; }
  100% { transform: scale(1); opacity: 1; }
}

#tipButton.pulsing .cube-face {
  animation: softPulse 1.8s ease-in-out infinite;
}
.puls {
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: none;
  box-shadow: none;
  animation: none;
  pointer-events: none;
}
</style>
</head>
<body>
  <!-- Ghost Restart Treasure (unsichtbar) -->
<div id="ghostRestartTreasure" title="Restarting..." style="
    position: absolute;
    top: 46.3%;
    left: 46.0%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: gold;
    cursor: default;
    z-index: 4000;
    box-shadow: 0 0 10px 3px gold;
    animation: pulse 2s infinite;
    display: none;
"></div>
 <div id="startScreen">
  <!-- Schatz versteckt -->
<div id="treasure" title="Click me!" style="
    position: absolute;
    top: 46.3%;
    left: 46.0%;
    transform: translate(-50%, -50%);
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: gold;
    cursor: pointer;
    z-index: 4000;
    box-shadow: 0 0 10px 3px gold;
    animation: pulse 2s infinite;
  "></div>
  <img src="IMG_1244.jpeg" alt="BrainTrials Logo">
</div>
  <div id="gameContainer">
  <h1></h1>
 <button id="startButton" onclick="startWordChain()">START</button> 
</div>
  <!-- Tip Button -->
<button id="tipButton">
  <span class="cube-face">‚óΩÔ∏è</span>
</button>

<!-- Modal f√ºr die Tipps -->
<div id="tipModal" class="modal">
  <div class="modal-content">
    <span class="close">&times;</span>
    <p></p>
  </div>
</div>
<!-- Welcome Video -->
<video id="welcomeVideo"
  muted
  playsinline
  preload="auto"
  style="
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: none;
    z-index: 5500;
    background: black;
  ">
  <source src="att.7KmgCeoPRAfcm8wOdhsPirAp4NqHkg-VfXklv2c3BSk.MP4" type="video/mp4">
</video>
  <script>


    // ========================== TIP BUTTON LOGIC =========================
const tipButton = document.getElementById('tipButton');
const cubeFace = tipButton.querySelector('.cube-face');

// TIP BUTTON erst nach 9 Sekunden erscheinen lassen
setTimeout(() => {
  


}, 9000);



const tipModal = document.getElementById('tipModal');
const closeBtn = document.querySelector('.close');

tipButton.onclick = () => {
  // üîÅ √∂ffnen / schlie√üen
  tipModal.classList.toggle('open');
  // üîÑ Puls steuern
  if (tipModal.classList.contains('open')) {
    tipButton.classList.remove('pulsing'); // Modal offen ‚Üí kein Puls
  } else {
    tipButton.classList.add('pulsing');    // Modal zu ‚Üí Puls an
  }
  // wenn geschlossen ‚Üí nichts machen
  if (!tipModal.classList.contains('open')) return;
  let tipText = '';
  if(stage === 'start') tipText = `
   <p><strong>BrainTrials</strong></p>

<p>
BrainTrials is a deterministic, rule-based cognitive system designed to validate
structured human input under real-time constraints.
</p>

<p>
The system does not rely on dictionaries, artificial intelligence, machine learning,
or probabilistic guessing.
All outcomes are derived exclusively from explicit rules, state transitions,
and input validation logic.
</p>

<p>
Each interaction is processed synchronously, ensuring immediate feedback without
latency, freezing, or hidden computation.
Invalid inputs are rejected through rule violations rather than semantic interpretation.
</p>

<p>
The architecture enforces progression through constrained stages, where advancement
depends on consistency, pattern recognition, and temporal accuracy.
This design results in a system that is resistant to brute-force input,
random noise, and exploit attempts.
</p>

<p>
BrainTrials functions as a closed logical environment:
correctness emerges from structure, not from stored knowledge.
All challenges are deterministic and reproducible.
</p>

<p>
The system implements multiple game modes:
Word Chain, Tic-Tac-Toe, Math Challenge, and Chromatic Trial ‚Äî
each testing different cognitive abilities such as memory,
pattern recognition, strategic planning, and rapid decision-making.
</p>

<p>
Scoring and progression are strictly governed by rules.
Success depends on precision, timing, and logical consistency ‚Äî
not on guesswork or probability.
</p>

<p>
BrainTrials is optimized for instantaneous feedback.
Every action triggers an immediate and deterministic response,
with no hidden operations or delayed evaluation.
</p>

<p>
<strong>Tip:</strong> Pay attention to structure.
Logical consistency, pattern awareness, and strategic foresight
are essential to advance.
</p>

<p>You are entering the arena of challenges.</p>
<p>Only those who think clearly, react quickly, and recognize patterns will reach the end.</p> 
  `;

  else if(stage === 'word') tipText = `
      <p>Word Chain Tips:</p>
    <ul>
      <li>Think of the last letter</li>
      <li>Find the Answer</li>
      <li>Longer or smarter</li>
    </ul>
  `;

  else if(stage === 'tic') tipText = `
      <p>Tic-Tac-Toe Tips:</p>
    <ul>
      <li>Get three to win</li>
      <li>Block your opponent</li>
      <li>Center is powerful</li>
      <li>It's simple!</li>
    </ul>
  `;

  else if(stage === 'math') tipText = `
      <p>Math Challenge Tips:</p>
    <ul>
      <li>Follow order 4 operations......</li>
      <li>Solve quickly time is running</li>
      <li>Correct answers let you advance</li>
      <li>Wrong answers,send you back</li>
    </ul>
  `;

  else if(stage === 'chromatic') tipText = `
      <p>Chromatic Trial Tips:</p>
    <ul>
      <li>Make all tiles the same color</li>
      <li>Focus on one color and act fast</li>
      <li>Or grid will reset</li>
    </ul>
  `;
  tipModal.querySelector('p').innerHTML = tipText;
  
};

closeBtn.onclick = () => {
  tipModal.classList.remove('open');
};

window.onclick = (e) => {
  if (e.target === tipModal) {
    tipModal.classList.remove('open');
  }
};
  
// ========================== VARIABLES ==========================
let stage='start', wordScore=0, ticScore={player:0,ai:0,draw:0};
let currentWord='', usedWords=[], wordList=[];
let board=[], gameOver=false;
let correctAnswer=0, correctMathCount=0;
let timer=10, timerInterval;
let mathTimer=30, mathTimerInterval;
let lastPlayerClick = 0; // Zeit des letzten Klicks
const clickCooldown = 300; // 300 ms zwischen erlaubten Klicks
let wrongAttempts = 0; // ‚úÖ RICHTIG PLATZIERT
let ghostRestartPending = false;
let ghostVisible = false;
function triggerGhostRestart() {
  ghostRestartPending = true;
}
let uiStarted = false;
function showWordError(text) {
  const message = document.getElementById('message');
  if (!message) return;

  message.textContent = text;
  message.style.opacity = "1";

  setTimeout(() => {
    message.textContent = "";
  }, 1200);
}
// ========================== WORD CHAIN ==========================
function startWordChain(){
  stage='word';
  const container=document.getElementById('gameContainer');
  container.innerHTML=`
      <h1></h1>
  <div id="wordDisplay">Apple</div>

  <div id="inputContainer">
    <input type="text" id="playerWord" placeholder="" autocomplete="off" autocapitalize="none">
    <button onclick="playWord()"> Check </button>
  </div>

  <div id="message"></div>

  <!-- üß† Brain Hint -->
  <div id="wordHint" style="
    margin-top:15px;
    font-family:'Press Start 2P', cursive;
    font-size:0.7em;
    color: white;
    min-height:18px;
    opacity:0;
    transition: opacity 0.5s;
  "></div>
`;
  currentWord='Apple'; usedWords=[currentWord];
  wordList=["Algorithm","Entropy","Hypothesis","Paradox","Labyrinth",
  "Quantum","Syntax","Recursion","Neural","Topology",
  "Cognition","Spectrum","Vector","Matrix","Anomaly",
  "Threshold","Resonance","Asymmetry","Continuum","Parable"];
}
  
function playWord(){
  const input=document.getElementById('playerWord');
  let word=input.value.trim(); word=word.charAt(0).toUpperCase()+word.slice(1);
  const message=document.getElementById('message');
  if(!word) return;
    // <-- HIER direkt nach dem Trim einf√ºgen:
  // ‚ùå Nur Buchstaben erlaubt
  if (!/^[a-zA-Z]+$/.test(word)) {
    wrongAttempt("Wrong");
    return;
}
  
  // Mindestl√§nge
if(word.length < 6){
  showWordError("Wrong");
  return;
}

// 2Ô∏è‚É£ Wiederholungs-Start
const startChar = word[0].toLowerCase();
let run = 0;
for (let c of word.toLowerCase()) {
  if (c === startChar) run++;
  else break;
}
if (run >= 4) {
  wrongAttempt("Wrong");
  return;
}

// 3Ô∏è‚É£ Buchstaben-Dominanz
const counts = {};
for (let c of word.toLowerCase()) {
  counts[c] = (counts[c] || 0) + 1;
}
const maxCount = Math.max(...Object.values(counts));
if (maxCount / word.length >= 0.7) {
  wrongAttempt("Wrong");
  return;
}

// 4Ô∏è‚É£ Varianz
if (new Set(word.toLowerCase()).size < 3) {
  wrongAttempt("Wrong");
  return;
}

  // Kein gleicher Endbuchstabe wie davor
const lastTwo = currentWord.slice(-2).toLowerCase();
if(word.slice(-1).toLowerCase() === lastTwo[0]){
  wrongAttempt("Wrong");
  return;
  
}
  const lastChar=currentWord.slice(-1).toLowerCase();
  const reversed=currentWord.split("").reverse().join("").toLowerCase();
  // üîí Blockiere ALLE Reverse-Varianten (auch manipulierte)
const blockedBase = reversed.slice(0, -1); // z.B. "larue"

if (
  word.toLowerCase().startsWith(blockedBase) &&
  word.length > blockedBase.length
) {
  wrongAttempt("Wrong");
  return;
}
  if(word[0].toLowerCase()!==lastChar){wrongAttempt("Wrong");return;}
  if(word.toLowerCase()===currentWord.toLowerCase()){wrongAttempt("Wrong");return;}
  
  if(usedWords.map(w=>w.toLowerCase()).includes(word.toLowerCase())){wrongAttempt("Already used");return;}
  usedWords.push(word); currentWord=word;
  document.getElementById('wordDisplay').textContent=``;
  input.value=''; message.textContent='';
  setTimeout(aiTurn,500);
}
function aiTurn(){
  const lastChar = currentWord.slice(-1).toLowerCase();
  let possible = wordList.filter(
    w => w[0].toLowerCase() === lastChar && !usedWords.includes(w)
  );// Wenn keine passenden W√∂rter ‚Üí Brain Hint
if(possible.length === 0){
  setTimeout(showWordChainHint, 5000);
  return;
}
  if(possible.length === 0){
    const remaining = wordList.filter(w => !usedWords.includes(w));
    if(remaining.length > 0){
      const r = remaining[Math.floor(Math.random() * remaining.length)];
      usedWords.push(r);
      currentWord = r;
      document.getElementById('wordDisplay').textContent = currentWord;
    }
    return;
  }

  let best = possible[0];
  let max = -1;

  for(let w of possible){
    const next = w.slice(-1).toLowerCase();
    const opts = wordList.filter(
      p => p[0].toLowerCase() === next && !usedWords.includes(p)
    );
    if(opts.length > max){
      max = opts.length;
      best = w;
    }
  } // ‚úÖ DIESE KLAMMER HAT GEFEHLT

  usedWords.push(best);
  currentWord = best;
  document.getElementById('wordDisplay').textContent = currentWord;

  wordScore++;

  if(wordScore >= 6){
    const msg = document.getElementById('message');
    msg.textContent = '';
    setTimeout(startTicTacToe, 500);
  }
}

function showWordChainHint() {
  if(stage !== 'word') return;

  const hint = document.getElementById('wordHint');
  if (!hint) return;

  hint.textContent = "Correct word allow progression";
  hint.style.opacity = "1";

  // ‚è≥ nach 3 Sekunden leiser Reset
  triggerGhostRestart();
  setTimeout(() => {
    restartGame();
    // üîë UI-Sequenz wieder erlauben
    uiStarted = false;
    startUISequence();
  }, 3000);
}


  function wrongAttempt(msg = "Wrong") {
  showWordError(msg);
  wrongAttempts++;

  if(wrongAttempts >= 4){
    triggerGhostRestart();
    setTimeout(restartGame, 800);
  }
}    
// ========================== TIC TAC TOE ==========================
function startTicTacToe(){
  stage='tic';
  const container=document.getElementById('gameContainer');
  container.innerHTML=`
    <h1></h1>
    <div id="boardWrapper"><div id="board"></div></div>
    <div id="timer">10</div>
    <div id="message"></div>
    <div id="scoreboard">Plays: 0 | AI: 0 | Draws: 0</div>
    <div id="level">
     <span>Level:</span> 
      <select id="levelSelect">
        <option value="easy">Easy</option>
        <option value="medium" selected>Medium</option>
        <option value="hard">Hard</option>
      </select>
    </div>
  `;
  board=['','','','','','','','','']; ticScore={player:0,ai:0,draw:0}; gameOver=false; renderBoard(); startTimer();
}

function renderBoard(){
  const b=document.getElementById('board');
  b.innerHTML='';
  board.forEach((c,i)=>{
    const d=document.createElement('div');
    d.className='cell';
    d.textContent=c;
    if(c==='') d.style.backgroundColor=randomColor();
    d.onclick=()=>playerMove(i);
    b.appendChild(d);
  });
}
function randomColor(){const c=["#808080",
"#ffffff",
"#808080",
"#ffffff",
"#808080",
"#ffffff",
"#808080",
"#ffffff",
"#808080"]; return c[Math.floor(Math.random()*c.length)];}
function startTimer(){clearInterval(timerInterval); timer=10; updateTimerUI(); timerInterval=setInterval(()=>{timer--; updateTimerUI(); if(timer===0){clearInterval(timerInterval); aiMove();}},1000);}
function updateTimerUI(){const d=document.getElementById('timer'); let seconds = String(timer).padStart(2, '0'); d.textContent=`00:${seconds}`; d.className=''; if(timer>=8)d.classList.add('timer-green'); else if(timer>=5)d.classList.add('timer-yellow'); else d.classList.add('timer-red');}
function playerMove(i){
  const now = Date.now();
  if(now - lastPlayerClick < clickCooldown) return; // zu schnell ‚Üí ignorieren
  lastPlayerClick = now;

  if(board[i]!=='') return; // Feld besetzt
  board[i]='X'; 
  clearInterval(timerInterval); 
  renderBoard(); 

  if(checkWinner('X')){
    gameOver=true;
    ticScore.player++;
    document.getElementById('message').textContent="You win";
    updateScore(); if(ticScore.player>=3){ setTimeout(startMathChallenge,800);}
    setTimeout(resetBoard,800);
    return;
  }

  if(board.every(c=>c!=='')){
    gameOver=true;
    ticScore.draw++;
    updateScore();
      // üü° NEU: 3 Draws ‚Üí zur√ºck zum Flow-Bild
  if (ticScore.draw >= 3) {
    triggerGhostRestart();
    setTimeout(restartGame, 800);
  } else {
    setTimeout(resetBoard, 800);
  }
  return;
}

  // AI-Zug nach kurzer Verz√∂gerung
  setTimeout(aiMove,400);
}
function aiMove(){if(gameOver)return; const lvl=document.getElementById('levelSelect').value; let move;if(lvl==='easy')move=randomMove(); else if(lvl==='medium')move=mediumMove(); else move=hardMove(); board[move]='O'; renderBoard(); if(checkWinner('O')){gameOver=true; ticScore.ai++; document.getElementById('message').textContent="AI wins"; updateScore(); if(ticScore.ai>=3){ setTimeout(startMathChallenge,800);} else { setTimeout(resetBoard,800);} return;} if(board.every(c=>c!=='')){gameOver=true; ticScore.draw++; updateScore();   // üü° NEU: 3 Draws ‚Üí zur√ºck zum Flow-Bild
  if (ticScore.draw >= 3) {
    setTimeout(restartGame, 800);
  } else {
    setTimeout(resetBoard, 800);
  }
  return;
} startTimer();}
function resetBoard(){board=['','','','','','','','','']; gameOver=false; document.getElementById('message').textContent=''; renderBoard(); startTimer();}
function randomMove(){const e=board.map((v,i)=>v===''?i:null).filter(v=>v!==null); return e[Math.floor(Math.random()*e.length)];}
function mediumMove(){for(let i=0;i<9;i++){if(board[i]===''){board[i]='O'; if(checkWinner('O'))return i; board[i]='';}} for(let i=0;i<9;i++){if(board[i]===''){board[i]='X'; if(checkWinner('X')){board[i]=''; return i;} board[i]='';}} if(board[4]==='') return 4; const c=[0,2,6,8].filter(i=>board[i]===''); if(c.length) return c[Math.floor(Math.random()*c.length)]; return randomMove();}
function hardMove(){let best=-Infinity; let move; for(let i=0;i<9;i++){if(board[i]===''){board[i]='O'; let s=minimax(board,0,false); board[i]=''; if(s>best){best=s; move=i;}}} return move;}
function minimax(b,d,max){if(checkWinner('O')) return 10-d; if(checkWinner('X')) return d-10; if(b.every(c=>c!=='')) return 0; if(max){let best=-Infinity; for(let i=0;i<9;i++){if(b[i]===''){b[i]='O'; best=Math.max(best,minimax(b,d+1,false)); b[i]='';}} return best;} else{let best=Infinity; for(let i=0;i<9;i++){if(b[i]===''){b[i]='X'; best=Math.min(best,minimax(b,d+1,true)); b[i]='';}} return best;}}
function checkWinner(p){const w=[[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]]; return w.some(x=>x.every(i=>board[i]===p));}
function updateScore(){document.getElementById('scoreboard').textContent=`Plays: ${ticScore.player} | AI: ${ticScore.ai} | Draws: ${ticScore.draw}`;}

// ========================== MATH CHALLENGE ==========================
function startMathChallenge(){
  stage='math';
  const container=document.getElementById('gameContainer');
  container.innerHTML=`
    <h1></h1>
    <div id="task">Loading...</div>
    <div id="inputContainer">
      <input id="answer" type="number" placeholder="" autofocus>
      <button onclick="checkMathAnswer()">Check</button>
    </div>
    <div id="timer">00:30</div>
    <div id="message"></div>
  `;
  mathTimer=30; generateMathTask(); startMathTimer();
}

function randomInt(min,max){return Math.floor(Math.random()*(max-min+1))+min;}
function generateMathTask(){const p=randomInt(1,3); let a,b,c,text; if(p===1){a=randomInt(10,40); b=randomInt(2,12); c=randomInt(5,30); correctAnswer=a+b*c; text=`${a} + ${b} √ó ${c}`;} if(p===2){a=randomInt(20,80); b=randomInt(2,10); c=randomInt(5,20); correctAnswer=a * b / c; text=`${a} √ó ${b} / ${c}`;} if(p===3){a=randomInt(20,80); b=randomInt(2,10); c=randomInt(2,6); correctAnswer=a-b*c; text=`${a} - ${b} √ó ${c}`;} document.getElementById('task').textContent=`${text} = `; document.getElementById('answer').value=''; document.getElementById('message').textContent=''; document.getElementById('answer').focus();}
function startMathTimer(){clearInterval(mathTimerInterval); mathTimerInterval=setInterval(()=>{mathTimer--; const d=document.getElementById('timer'); const seconds = String(mathTimer).padStart(2, '0'); d.textContent=`00:${seconds}`; d.className=''; if(mathTimer>=20)d.classList.add('timer-green'); else if(mathTimer>=10)d.classList.add('timer-yellow'); else d.classList.add('timer-red'); if(mathTimer<=0){clearInterval(mathTimerInterval); correctMathCount=0; triggerGhostRestart(); restartGame(); }},1000);}
function checkMathAnswer(){const input=document.getElementById('answer'); if(input.value==='')return; clearInterval(mathTimerInterval); let userAnswer = Number(input.value);
let correctRounded = Number(correctAnswer.toFixed(4));

if(Math.abs(userAnswer - correctRounded) < 0.0001){correctMathCount++; document.getElementById('message').textContent='Correct'; if(correctMathCount>=9){ setTimeout(startChromaticTrial,700); return;} setTimeout(()=>{mathTimer=30; generateMathTask(); startMathTimer();},700);} else{document.getElementById('message').textContent='Wrong'; correctMathCount=0; setTimeout(triggerGhostRestart,1000); setTimeout(restartGame,1000); }}

// ========================== CHROMATIC TRIAL ==========================
const colorsCT=["#ba68c8",
"#64b5f6",
"#81c784",
"#A0522D",
"#ffb74d",
"#808080",
"#e57373",
"#ffffff",
"#4dd0e1"];
const CHROMATIC_GOAL="#ba68c8"; 
let tilesCT=[], chromaticTime=60, chromaticTimerInterval, uniformTimeout=null, solved=false;

function startChromaticTrial(){
  stage='chromatic';
  const container=document.getElementById('gameContainer');
  container.innerHTML=`
  <h1></h1>

    
    <div id="chromaticText" style="
      margin-bottom:15px;
      font-family:'Press Start 2P', cursive;
      font-size: 0.7em;
      color: white;
      min-height:18px;
      opacity:0;
      transition: opacity 0.5s;
    "></div>

   
    <div id="grid"></div>

    
    <div id="chromaticWinText" style="
      position: fixed;
      top: 54%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Press Start 2P', cursive;
      font-size: 1em;
      color: #ffffff;
      text-align: center;
      opacity: 0;
      transition: opacity 1s;
      pointer-events: none;
    ">
      Correct<br>
    </div>

    
    <div id="timer">60</div>
  `;

  createChromaticGrid();
  startChromaticTimer();

  // üëâ Text nach 10 Sekunden anzeigen
  setTimeout(showChromaticMessage, 10000);
}  

function createChromaticGrid(){
  const grid = document.getElementById('grid');
  grid.innerHTML = '';
  tilesCT = [];
  solved = false;

  for(let i=0; i<9; i++){
    const tile = document.createElement('div');
    tile.className = 'tile';

    const idx = Math.floor(Math.random() * colorsCT.length);
    tile.dataset.color = idx;
    tile.style.backgroundColor = colorsCT[idx];

       tile.onclick = () => {
      cycleColor(tile);
      checkWin();
      checkUniformReset();
    };

    tilesCT.push(tile);
    grid.appendChild(tile);
  }
}

// Farbe wechseln beim Klick
function cycleColor(tile){
  if(solved) return;
  let idx = Number(tile.dataset.color);
  idx = (idx + 1) % colorsCT.length;
  tile.dataset.color = idx;
  tile.style.backgroundColor = colorsCT[idx];
}

// Pr√ºfen, ob alle Felder die Ziel-Farbe haben
function checkWin(){
  const allGoal = tilesCT.every(
    t => colorsCT[Number(t.dataset.color)] === CHROMATIC_GOAL
  );

  if(allGoal && !solved){
    solved = true;
    clearInterval(chromaticTimerInterval);
    clearTimeout(uniformTimeout);
    showChromaticWin();
    
  }
}
function resetChromaticColors() {
  tilesCT.forEach(tile => {
    const idx = Math.floor(Math.random() * colorsCT.length);
    tile.dataset.color = idx;
    tile.style.backgroundColor = colorsCT[idx];
  });
}
// Pr√ºfen, ob alle Felder die gleiche Farbe haben (nicht unbedingt Ziel-Farbe)
function checkUniformReset(){
  const firstColor = colorsCT[Number(tilesCT[0].dataset.color)];
  const allSame = tilesCT.every(t => colorsCT[Number(t.dataset.color)] === firstColor);
  if(allSame && !solved){
    clearTimeout(uniformTimeout);
    uniformTimeout = setTimeout(() => {
      resetChromaticColors(); // Reset auf neue zuf√§llige Farben
    }, 2000); // 2 Sekunden warten
  } else {
    clearTimeout(uniformTimeout);
  }
}

// Timer starten
function startChromaticTimer(){
  clearInterval(chromaticTimerInterval);
  chromaticTime = 60;
  const timerDiv = document.getElementById('timer');

  // erste Anzeige
  let seconds = String(chromaticTime).padStart(2, '0');
  timerDiv.textContent = `00:${seconds}`;

  chromaticTimerInterval = setInterval(()=>{
    chromaticTime--;

    let seconds = String(chromaticTime).padStart(2, '0');
    timerDiv.textContent = `00:${seconds}`;

    timerDiv.className = '';
    if(chromaticTime > 30) timerDiv.classList.add('timer-green');
    else if(chromaticTime > 10) timerDiv.classList.add('timer-yellow');
    else timerDiv.classList.add('timer-red');

    if(chromaticTime <= 0){
      clearInterval(chromaticTimerInterval);
      clearTimeout(uniformTimeout);
      triggerGhostRestart(); restartGame();
    }
  }, 1000);
}

function showChromaticMessage(){
  var text = document.getElementById('chromaticText');
  if(!text) return;

  text.textContent = " Find the right Color";
  text.style.opacity = "1";

  setTimeout(function(){
    text.style.opacity = "0";
  }, 3000);
}
function restartGame(){
  clearInterval(chromaticTimerInterval);
  clearInterval(mathTimerInterval);
  clearTimeout(uniformTimeout);
  
  wrongAttempts = 0; // üîë WICHTIG
  
  // Variablen zur√ºcksetzen
  stage = 'start';
  wordScore = 0;
  ticScore = {player:0, ai:0, draw:0};
  currentWord = '';
  usedWords = [];
  board = [];
  gameOver = false;
  correctAnswer = 0;
  correctMathCount = 0;

  // Spiel ausblenden
  document.getElementById('gameContainer').style.display = 'none';

  // Flow-Bild anzeigen
  const startScreen = document.getElementById('startScreen');
  startScreen.style.display = 'flex';
    // üëª GHOST ERSCHEINT ERST JETZT
if (ghostRestartPending && !ghostVisible) {
  showGhostRestartTreasure();
  ghostVisible = true;
 // üîë UI-Sequenz wieder erlauben
  uiStarted = false;
  startUISequence();
 }
}
function showChromaticWin() {
  const text = document.getElementById('chromaticWinText');
  if(!text) return;

text.style.opacity = "1";
 triggerGhostRestart();
  setTimeout(() => {
    restartGame();
    // üîë UI-Sequenz wieder erlauben
    uiStarted = false;
    startUISequence();
  }, 5000); // ‚è± nach 5 Sekunden zur√ºck zum Start
}
function globalRestartFromTreasure() {
  // üîÅ ZUERST: kompletten Game-State resetten
  restartGame();

  // üëª Ghost zur√ºcksetzen
  const ghost = document.getElementById('ghostRestartTreasure');
  ghost.style.display = 'none';
  ghostRestartPending = false;
  ghostVisible = false;

  // Flow-Bild aus
  document.getElementById('startScreen').style.display = 'none';

  // Game anzeigen
  document.getElementById('gameContainer').style.display = 'flex';

  // UI neu starten
  uiStarted = false;
  startUISequence();
}
treasure.onclick = (e) => {
  e.stopPropagation(); // üîë GANZ WICHTIG
  globalRestartFromTreasure();

// Funken erzeugen
  for(let i=0; i<5; i++){
    const spark = document.createElement('div');
    spark.className = 'spark';
    spark.style.top = (e.clientY + (Math.random()*20-10)) + 'px';
    spark.style.left = (e.clientX + (Math.random()*20-10)) + 'px';
    document.body.appendChild(spark);
    setTimeout(() => spark.remove(), 1000);
  }

  // Text anzeigen
  const msg = document.createElement('div');
  msg.textContent = "Welcome";
  msg.style.position = 'fixed';
  msg.style.top = '10%';
  msg.style.left = '50%';
  msg.style.transform = 'translate(-50%, -50%)';
  msg.style.background = 'none';
  msg.style.color = 'white';
  msg.style.padding = '12px 20px';
  msg.style.borderRadius = '12px';
  msg.style.fontFamily = "'Press Start 2P', cursive";
  msg.style.fontSize = '1.4em';
  msg.style.zIndex = '5000';
  msg.style.opacity = '0';
  msg.style.transition = 'opacity 15s';
  document.body.appendChild(msg);
  setTimeout(() => msg.style.opacity = '1', 50);
  setTimeout(() => msg.remove(), 8000);
// üé¨ Welcome-Video starten nach 3 Sekunden
setTimeout(() => {
  const video = document.getElementById('welcomeVideo');
  if (video) {
    video.style.display = 'block';
    video.currentTime = 0;
    video.play();
  }
}, 7000);

// üé¨ Video nach 6 Sekunden wieder ausblenden
setTimeout(() => {
  const video = document.getElementById('welcomeVideo');
  if (video) {
    video.pause();
    video.style.display = 'none';
  }
}, 13000); // 3s warten + 6s Video
 
};

function startUISequence() {
  if (uiStarted) return; // üîí nur einmal
  uiStarted = true;

  // TIP BUTTON nach 30s
  setTimeout(() => {
    tipButton.classList.add('show');
    tipButton.classList.add('roll');

    setTimeout(() => {
      cubeFace.textContent = '‚ùï';
      tipButton.classList.remove('roll');
      tipButton.classList.add('pulsing');
    }, 2000);
  }, 30000);

  // START BUTTON nach 1:30
  setTimeout(() => {
    const btn = document.getElementById('startButton');
    if (btn) {
      btn.style.opacity = '1';
      btn.style.pointerEvents = 'auto';
    }
  }, 90000);
}




</script>
</body>
</html>


<!--BrainTrials

Created by G√´zim Hasani
¬© 2025

This project is protected by copyright law.
Copying, selling, or redistributing this project
or parts of it without permission is prohibited.




All rights reserved.
-->
